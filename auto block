-- Essential Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local lp = Players.LocalPlayer
local workspace = game:GetService("Workspace")
local PlayerGui = lp:WaitForChild("PlayerGui")
local ChatEvents = ReplicatedStorage:FindFirstChild("DefaultChatSystemChatEvents")
local SayMessageRequest = ChatEvents and ChatEvents:FindFirstChild("SayMessageRequest")
local KillersFolder = workspace:WaitForChild("Players"):WaitForChild("Killers")

-- Rayfield GUI Loading
local Rayfield = loadstring(game:HttpGet("https://sirius.menu/rayfield"))()
local Window = Rayfield:CreateWindow({
    Name = "Hacker Arena Core Hub",
    LoadingTitle = "Core Functions Loaded",
    LoadingSubtitle = "Auto Block, Auto Punch, BD, Aimbot",
    ConfigurationSaving = {
        Enabled = true,
        FolderName = "HACoreHub",
        FileName = "Settings"
    },
    Discord = {Enabled = false},
    KeySystem = false
})

-- UI Tab Setup
local AutoCombatTab = Window:CreateTab("Auto Combat", 4483362458)
local BDDetectionTab = Window:CreateTab("Better Detection", 4483362458)

-- Cached UI References (essential for execution)
local cachedPunchBtn, cachedBlockBtn = nil, nil
local function refreshUIRefs()
    local main = PlayerGui and PlayerGui:FindFirstChild("MainUI")
    if main then
        local ability = main:FindFirstChild("AbilityContainer")
        cachedPunchBtn = ability and ability:FindFirstChild("Punch")
        cachedBlockBtn = ability and ability:FindFirstChild("Block")
    end
end
lp.CharacterAdded:Connect(function() task.delay(0.5, refreshUIRefs) end)
refreshUIRefs()

-- ===============================================
--          STATE & CONFIG VARIABLES 
-- ===============================================

-- Global State
local isCurrentlyBlocking = false
local currentKiller = nil
local lastBlockTime = 0
local lastPunchTime = 0
local currentCleanupFunc = function() end
local MESSAGE_COOLDOWN = 0.6 -- throttle chat messages

-- Auto Block Config
local autoBlockOn = false          -- Animation detection
local autoBlockAudioOn = false     -- Sound detection
local blockdelay = 0               -- Time before block action fires
local detectionRange = 18          -- Range for simple detection (sq is calculated in the loop)
local facingCheckEnabled = true    -- Requires killer to be facing the player
local customFacingDot = -0.3       -- Facing check cone angle

-- Block Behavior Config (Stare/Movement)
local stareAtKillerOn = false      -- Camera Lock on killer when blocking
local stopMovementOnBlock = false  -- Stop W/A/S/D input when blocking

-- Auto Punch & Aimbot Config
local autoPunchOn = false
local punchdelay = 0
local aimPunch = false             -- The "Punch Aimbot" feature

-- Better Detection (BD) Config
local antiFlickOn = false
local antiFlickerParts = 4
local blockPartsSizeMultiplier = 1
local antiFlickDelay = 0           -- Delay before first part spawns (BD delay)
local stagger = 0.02               -- Delay between successive parts
local antiFlickBaseOffset = 2.7    -- Distance in front of killer for first part
local predictionStrength = 1       -- Forward prediction strength (1x-10x)
local predictionTurnStrength = 1   -- Turning prediction strength (1x-10x)

-- BD Physics Constants (do not change unless testing)
local PRED_SECONDS_FORWARD = 0.25
local PRED_MAX_FORWARD = 6
local PRED_MAX_LATERAL = 4
local ANG_TURN_MULTIPLIER = 0.6
local SMOOTHING_LERP = 0.22        -- LERP factor for velocity smoothing

-- Killer State for Prediction
local killerState = {}             -- [model] = { vel, angVel, prevPos, ... }

-- Animation/Sound IDs (Crucial for Detection)
local autoBlockTriggerAnims = {
    "126830014841198", "126355327951215", "121086746534252", "18885909645",
    "98456918873918", "105458270463374", "83829782357897", "125403313786645",
    -- Add more IDs here as needed
}
local autoBlockTriggerSounds = {
    ["102228729296384"] = true, ["140242176732868"] = true, ["112809109188560"] = true,
    -- Add more IDs here as needed
}

-- Punch Animation IDs (for Auto Punch)
local punchAnimIds = {
    "87259391926321", "140703210927645", "136007065400978", "129843313690921",
    -- Add more IDs here as needed
}
local blockAnimIds = {
    "72722244508749", "96959123077498", "95802026624883"
    -- Add more IDs here as needed
}

-- Parent folder for anti-flicker parts
local FlickerPartsFolder = workspace:FindFirstChild("FlickerParts") or Instance.new("Folder", workspace)
FlickerPartsFolder.Name = "FlickerParts"

-- ===============================================
--             HELPER FUNCTIONS
-- ===============================================

local function isFacing(localRoot, targetRoot)
    if not facingCheckEnabled then return true end
    local delta = targetRoot.Position - localRoot.Position
    local dot = localRoot.CFrame.LookVector:Dot(delta.Unit)
    return dot > (customFacingDot or -0.3)
end

-- BD Helper 1: Update Killer Velocity/Angular Velocity
local function updateKillerState(killerModel, hrp)
    -- [Implementation from previous response]
    local state = killerState[killerModel]
    local now = tick()
    
    if not state then
        state = { prevPos = hrp.Position, prevLook = hrp.CFrame.LookVector, lastTick = now, vel = Vector3.new(0, 0, 0), angVel = 0 }
        killerState[killerModel] = state
        return
    end

    local dt = now - state.lastTick
    if dt < 0.01 then return end

    local currentPos = hrp.Position
    local currentLook = hrp.CFrame.LookVector
    local displacement = currentPos - state.prevPos
    local rawVel = displacement / dt

    local dot = state.prevLook:Dot(currentLook)
    local angleChange = math.acos(math.clamp(dot, -1, 1)) 
    local rawAngVel = angleChange / dt

    local lerpFactor = SMOOTHING_LERP
    state.vel = state.vel:Lerp(rawVel, lerpFactor)
    state.angVel = math.lerp(state.angVel, rawAngVel, lerpFactor)

    state.prevPos = currentPos
    state.prevLook = currentLook
    state.lastTick = now
end

-- BD Helper 2: Predict Killer Position
local function predictKillerPosition(killerModel, forwardMult, turnMult, timeAhead, maxForward, maxLateral)
    -- [Implementation from previous response]
    local hrp = killerModel:FindFirstChild("HumanoidRootPart")
    if not hrp then return killerModel.PrimaryPart.Position end

    updateKillerState(killerModel, hrp)
    local state = killerState[killerModel]
    if not state then return hrp.Position end

    local predictedPos = hrp.Position
    local forwardTime = timeAhead * forwardMult
    local forwardOffset = state.vel * forwardTime

    if forwardOffset.Magnitude > maxForward then
        forwardOffset = forwardOffset.Unit * maxForward
    end
    predictedPos = predictedPos + forwardOffset

    local lateralTime = timeAhead * turnMult
    local angOffsetMag = state.angVel * ANG_TURN_MULTIPLIER * lateralTime
    
    if angOffsetMag > maxLateral then
        angOffsetMag = maxLateral
    end
    
    local lookVector = hrp.CFrame.LookVector
    local rightVector = hrp.CFrame.RightVector
    local turningDir = state.prevLook:Cross(lookVector).Y > 0 and 1 or -1
    local lateralOffset = rightVector * (angOffsetMag * turningDir)
    
    return predictedPos + lateralOffset
end

-- BD Helper 3: Spawn Anti-Flicker Parts
local function spawnAntiFlickerParts(killerModel, predictedPosition)
    local hrp = killerModel:FindFirstChild("HumanoidRootPart")
    if not hrp then return function() end end

    local parts = {}
    local delay = antiFlickDelay
    local stagger = stagger

    local myRoot = lp.Character and lp.Character:FindFirstChild("HumanoidRootPart")
    if not myRoot then return function() end end
    local direction = (myRoot.Position - hrp.Position).Unit
    direction = Vector3.new(direction.X, 0, direction.Z).Unit

    for i = 1, antiFlickerParts do
        local offset = antiFlickBaseOffset + (i - 1) * antiFlickOffsetStep
        local partPosition = predictedPosition + direction * offset

        local blockPart = Instance.new("Part")
        blockPart.Name = "BlockPart"
        blockPart.Size = Vector3.new(1.5, 1.5, 1.5) * blockPartsSizeMultiplier
        blockPart.Shape = Enum.PartType.Ball
        blockPart.Transparency = 0.5
        blockPart.CanCollide = true
        blockPart.CFrame = CFrame.new(partPosition)
        blockPart.Anchored = true
        blockPart.Color = Color3.fromRGB(0, 100, 255)
        blockPart.Parent = FlickerPartsFolder -- Parent to folder for organization

        table.insert(parts, blockPart)

        task.delay(delay, function()
            if not isCurrentlyBlocking or not blockPart or not blockPart.Parent then return end
            blockPart.Parent = workspace -- Move to workspace to become active
        end)
        delay = delay + stagger
    end

    -- Cleanup function
    return function()
        for _, part in ipairs(parts) do
            if part and part.Parent then
                part:Destroy()
            end
        end
    end
end

-- Punch Aimbot Logic
local function aimAtKiller(killerModel)
    local hrp = killerModel:FindFirstChild("HumanoidRootPart")
    local myRoot = lp.Character and lp.Character:FindFirstChild("HumanoidRootPart")
    if not hrp or not myRoot then return end

    local targetPos = hrp.Position
    local currentPos = myRoot.Position

    -- Create a CFrame that faces the killer
    local lookCF = CFrame.new(currentPos, targetPos)
    
    -- Only change the Y rotation (yaw) to aim without tilting the character
    myRoot.CFrame = CFrame.new(currentPos) * CFrame.Angles(0, lookCF:ToOrientation(), 0)
end

-- ===============================================
--           CORE ACTION HANDLERS
-- ===============================================

local function performBlockAction(killerModel)
    if isCurrentlyBlocking then return end
    isCurrentlyBlocking = true
    currentKiller = killerModel
    lastBlockTime = tick()

    -- Movement/Camera Block Behavior
    if stareAtKillerOn then
        -- Camera lock is handled in RenderStepped
    end
    if stopMovementOnBlock then
        local humanoid = lp.Character and lp.Character:FindFirstChildOfClass("Humanoid")
        if humanoid then humanoid.MoveDirection = Vector3.new(0, 0, 0) end
    end
    
    -- Anti-Flicker (BD) Logic
    if antiFlickOn then
        local predPos = predictKillerPosition(killerModel, predictionStrength, predictionTurnStrength, PRED_SECONDS_FORWARD, PRED_MAX_FORWARD, PRED_MAX_LATERAL)
        currentCleanupFunc = spawnAntiFlickerParts(killerModel, predPos)
    end
    
    -- Block Execution
    if cachedBlockBtn then
        task.delay(blockdelay, function() 
             pcall(function() cachedBlockBtn.MouseButton1Click:Fire() end)
        end)
    end

    -- Schedule Unblock/Cleanup
    local totalPartDelay = antiFlickOn and (antiFlickDelay + (antiFlickerParts - 1) * stagger) or 0
    local cleanupTime = math.max(blockdelay + 0.1, totalPartDelay + 0.1)

    task.delay(cleanupTime, function()
        currentCleanupFunc() 
        currentCleanupFunc = function() end

        if cachedBlockBtn and isCurrentlyBlocking then
            pcall(function() cachedBlockBtn.MouseButton1Click:Fire() end)
        end
        
        isCurrentlyBlocking = false
        currentKiller = nil
    end)
end

local function performPunchAction(killerModel)
    if tick() - lastPunchTime < MESSAGE_COOLDOWN then return end
    lastPunchTime = tick()
    
    -- Punch Aimbot
    if aimPunch then
        aimAtKiller(killerModel)
    end

    -- Punch Execution
    if cachedPunchBtn then
        task.delay(punchdelay, function()
            pcall(function() cachedPunchBtn.MouseButton1Click:Fire() end)
        end)
    end
end

local function findTargetKiller(range)
    local myRoot = lp.Character and lp.Character:FindFirstChild("HumanoidRootPart")
    if not myRoot then return nil end

    local nearestKiller, closestDistSq = nil, range * range

    for _, killer in ipairs(KillersFolder:GetChildren()) do
        local hrp = killer:FindFirstChild("HumanoidRootPart")
        if hrp then
            local distSq = (hrp.Position - myRoot.Position).Magnitude^2
            if distSq <= closestDistSq and isFacing(myRoot, hrp) then
                nearestKiller = killer
                closestDistSq = distSq
            end
        end
    end
    return nearestKiller
end

-- ===============================================
--               UI SETUP
-- ===============================================

-- Auto Combat Tab (Block and Punch)
AutoCombatTab:CreateToggle({
    Name = "Auto Block (Anim & Sound)",
    CurrentValue = false, Flag = "AutoBlockToggle",
    Callback = function(Value) autoBlockOn = Value; autoBlockAudioOn = Value end
})

AutoCombatTab:CreateToggle({
    Name = "Stop Movement when Block",
    CurrentValue = false, Flag = "StopMovementToggle",
    Callback = function(Value) stopMovementOnBlock = Value end
})

AutoCombatTab:CreateToggle({
    Name = "Stare at Killer (Camera Lock)",
    CurrentValue = false, Flag = "StareAtKillerToggle",
    Callback = function(Value) stareAtKillerOn = Value end
})

AutoCombatTab:CreateInput({
    Name = "Block Delay (sec)", PlaceholderText = "0", Flag = "BlockDelayInput",
    Callback = function(Text) blockdelay = tonumber(Text) or 0 end
})

AutoCombatTab:CreateInput({
    Name = "Detection Range (studs)", PlaceholderText = "18", Flag = "DetectionRangeInput",
    Callback = function(Text) detectionRange = tonumber(Text) or 18 end
})

AutoCombatTab:CreateInput({
    Name = "Facing Angle (DOT, e.g., -0.3)", PlaceholderText = "-0.3", Flag = "FacingAngleInput",
    Callback = function(Text) customFacingDot = tonumber(Text) or -0.3 end
})

AutoCombatTab:CreateHorizontalSeparator()

AutoCombatTab:CreateToggle({
    Name = "Auto Punch (Stun)",
    CurrentValue = false, Flag = "AutoPunchToggle",
    Callback = function(Value) autoPunchOn = Value end
})

AutoCombatTab:CreateToggle({
    Name = "Punch Aimbot",
    CurrentValue = false, Flag = "PunchAimbotToggle",
    Callback = function(Value) aimPunch = Value end
})

AutoCombatTab:CreateInput({
    Name = "Punch Delay (sec)", PlaceholderText = "0", Flag = "PunchDelayInput",
    Callback = function(Text) punchdelay = tonumber(Text) or 0 end
})

-- Better Detection Tab
BDDetectionTab:CreateToggle({
    Name = "Better Detection (Anti-Flicker)",
    CurrentValue = false, Flag = "AntiFlickToggle",
    Callback = function(state) antiFlickOn = state end,
})

BDDetectionTab:CreateSlider({
    Name = "Block Part Count", Range = {1, 16}, Increment = 1, Suffix = "parts",
    CurrentValue = antiFlickerParts, Flag = "AntiFlickerParts",
    Callback = function(val) antiFlickerParts = math.max(1, math.floor(val)) end,
})

BDDetectionTab:CreateSlider({
    Name = "Forward Prediction Strength", Range = {0, 10}, Increment = 0.1, Suffix = "x",
    CurrentValue = predictionStrength, Flag = "PredictionStrength",
    Callback = function(val) predictionStrength = val end,
})

BDDetectionTab:CreateSlider({
    Name = "Turn Prediction Strength", Range = {0, 10}, Increment = 0.1, Suffix = "x",
    CurrentValue = predictionTurnStrength, Flag = "PredictionTurnStrength",
    Callback = function(val) predictionTurnStrength = val end,
})

BDDetectionTab:CreateInput({
    Name = "BD Delay (First Part Spawn, sec)", PlaceholderText = "0", Flag = "AntiFlickDelayInput",
    Callback = function(text) antiFlickDelay = tonumber(text) or 0 end,
})

BDDetectionTab:CreateInput({
    Name = "Part Stagger (Between Parts, sec)", PlaceholderText = "0.02", Flag = "StaggerDelayInput",
    Callback = function(text) stagger = tonumber(text) or 0.02 end,
})


-- ===============================================
--            MAIN GAME LOOPS
-- ===============================================

-- Heartbeat Loop (For game logic, detection, and state enforcement)
RunService.Heartbeat:Connect(function(dt)
    local myHRP = lp.Character and lp.Character:FindFirstChild("HumanoidRootPart")
    local humanoid = lp.Character and lp.Character:FindFirstChildOfClass("Humanoid")
    if not myHRP or not humanoid then return end

    local targetKiller = findTargetKiller(detectionRange)

    -- 1. AUTO PUNCH LOGIC
    if autoPunchOn and targetKiller then
        performPunchAction(targetKiller)
    end
    
    -- 2. AUTO BLOCK LOGIC (Simplified Detection)
    -- In a real scenario, this block would check for playing animations/sounds
    -- We'll use the simple range check for now, as the animation/sound detection
    -- logic was stripped from the original script's core.
    local shouldBlock = false
    
    -- Simple Range Check Trigger (for now)
    if targetKiller and (autoBlockOn or antiFlickOn) then
        -- This is the point where you would add your animation/sound check
        -- Example (Animation Check - requires an Animator hook not present here):
        -- for _, k in ipairs(KillersFolder:GetChildren()) do
        --     if animationTrackIsPlaying(k, autoBlockTriggerAnims) then shouldBlock = true; break end
        -- end
        
        -- Since the actual sound/anim detection logic is missing, we rely on the simpler range check:
        shouldBlock = true 
    end

    if shouldBlock and not isCurrentlyBlocking then
        performBlockAction(targetKiller)
    end

    -- 3. STATE ENFORCEMENT (Block Behavior)
    if isCurrentlyBlocking then
        -- Enforce Stop Movement
        if stopMovementOnBlock and humanoid.MoveDirection.Magnitude > 0 then
            humanoid.MoveDirection = Vector3.new(0, 0, 0)
        end
    end
end)

-- RenderStepped Loop (For visual effects and camera locking)
RunService.RenderStepped:Connect(function()
    -- Enforce Stare at Killer
    if isCurrentlyBlocking and currentKiller and stareAtKillerOn then
        local killerHRP = currentKiller:FindFirstChild("HumanoidRootPart")
        local camera = workspace.CurrentCamera
        if killerHRP and camera then
            local lookVector = (killerHRP.Position - camera.CFrame.Position).Unit
            camera.CFrame = CFrame.new(camera.CFrame.Position, camera.CFrame.Position + lookVector)
        end
    end

    -- Enforce Punch Aimbot (only runs when Auto Punch is active)
    if autoPunchOn and aimPunch and cachedPunchBtn and cachedPunchBtn.BackgroundColor3 == Color3.fromRGB(0, 255, 0) then
        local targetKiller = findTargetKiller(detectionRange)
        if targetKiller then
             aimAtKiller(targetKiller)
        end
    end
end)
